package finalp;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.List;
import java.time.Clock;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.Vector;
import static java.util.logging.Logger.global;
import javax.sound.midi.SysexMessage;
import javax.swing.JFrame;

/**
 *
 * @author USER
 */
public class myPoints extends javax.swing.JFrame {
    JFrame myPoints; 
    int c=0;
    public Vector<sensor> sensors;
    public Vector<particle> particles;
    int numOfPar=150;
    Graphics g;
    particle jammer;
    int numOfPoints;
    PriorityQueue<best> bestLines=new PriorityQueue<>();
    static int InitialMinDistanceToFix  = 40;
    static int InitialMaxDistacneToSense = 250;
    int MaxSnr  = 50;
    /**
     * Creates new form myPoints
     */
    public myPoints() {
        initComponents();
        this.sensors = new Vector<sensor>();
        this.particles = new Vector<particle>();
        jammer=new particle(jPanel1.getWidth()/3,jPanel1.getHeight()/3,0);
        numOfPoints=200;
    }
    
        
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jFrame1 = new javax.swing.JFrame();
        jPanel1 = new javax.swing.JPanel();
        getPoints = new javax.swing.JButton();
        findJammer = new javax.swing.JButton();
        action = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();

        javax.swing.GroupLayout jFrame1Layout = new javax.swing.GroupLayout(jFrame1.getContentPane());
        jFrame1.getContentPane().setLayout(jFrame1Layout);
        jFrame1Layout.setHorizontalGroup(
            jFrame1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        jFrame1Layout.setVerticalGroup(
            jFrame1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        getPoints.setText("getPoints");
        getPoints.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                getPointsActionPerformed(evt);
            }
        });

        findJammer.setText("particles");
        findJammer.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                findJammerActionPerformed(evt);
            }
        });

        action.setText("Action");
        action.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                actionActionPerformed(evt);
            }
        });

        jLabel1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/finalp/p1 (1).png"))); // NOI18N
        jLabel1.setText("jLabel1");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(getPoints)
                    .addComponent(action)
                    .addComponent(findJammer))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 1010, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(40, 40, 40)
                        .addComponent(getPoints)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(findJammer)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(action))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 442, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void getPointsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_getPointsActionPerformed
        // TODO add your handling code here:
        g=jPanel1.getGraphics();
        g.setColor(Color.blue);
        int size=10;
        g.fillRect(jammer.x, jammer.y, size, size);
       
        double distance;
        int volume;
        int x,y;
        for(int i=0;i<numOfPoints;i++){
            x=(int)(Math.random()*jPanel1.getWidth());
            y=(int)(Math.random()*jPanel1.getHeight());
            distance=dist(x,y,jammer.x,jammer.y);
            //System.out.println(distance);
            volume=vol(jammer.x,jammer.y, x,y,jammer.val);
           //System.out.println(volume);
            sensor p=new sensor(x,y,distance,volume,0,0);
            //System.out.println(p.x + " "+p.y);
            sensors.add(p);
            //g.fillRect(p.x, p.y, size/2, size/2);
        }
    }//GEN-LAST:event_getPointsActionPerformed
    private double [] Normal_Weights()
    {
        double MaxWeight=0;
        Vector <particle> doubleWeight = new Vector<particle>();
        double[] Weights=new double[numOfPar];
        for(particle tmp : this.particles)
        {
            MaxWeight+=tmp.w;
        }
        int i=0;
        for(particle tmp : this.particles)
        {
            Weights[i]=tmp.w/MaxWeight;
            i++;
        }
        return Weights;
    }
   public double GetMax(double[] Weights)
    {
        double max=Weights[0];
        for(int i=1;i<Weights.length; i++)
        {
            if(Weights[i]>=max)
            max=Weights[i];
        }
        return  max;
    }
  

    public void unitParticle(){
        g.setColor(Color.YELLOW);
       for(int i=0;i<numOfPar;i++){
            int x=(int)(Math.random()*jPanel1.getWidth());
            int y=(int)(Math.random()*jPanel1.getHeight());
            particle p=new particle(x, y, 0);
            particles.add(p);
           g.fillRect(x, y, 3, 3);
       }
    }
   
   //double dist(int X1, int Y1, int X2, int Y2)
   //{
     //  return  Math.sqrt((X1-X2)^2+(Y1-Y2));

  // }


    //// TODO: 8/1/2016 Eden & Michal. Power can be between 1-2.
    public int vol(int JamX, int Jamy, int SensorX, int SensorY, double Power)
    {

        double MaxDistacneToSense = InitialMaxDistacneToSense*Power;
        double MinDistanceToFix =  InitialMinDistanceToFix*Power/2;

        double dist = dist(JamX,Jamy,SensorX,SensorY);
        System.out.println("dist is:"+ dist);
        if(dist>MaxDistacneToSense)
            return MaxSnr;
        else if(dist<MinDistanceToFix)
            return 0;
        else
        {
            double m = MaxSnr/(MaxDistacneToSense-MinDistanceToFix);
            double ComputedSnr = m*(dist-MinDistanceToFix);
            return (int)ComputedSnr;
        }

    }

      /* public int vol(int x, int y,particle jam){
        double d=dist(x,y,jam.x,jam.y);
        d=Math.sqrt(d);
       // System.out.println("distance: "+d);
        if(d<50)return 0;
        else if(d>50&&d<250)return (int)(Math.pow((d-50),2)/1000);
        else return 50;
    }*/
   public double dist(int x1,int y1,int x2,int y2){
       return Math.sqrt(Math.pow((x1-x2),2)+Math.pow((y1-y2),2));
   }
   
    public void sense(){
       double disSnr,v,d,demoSnr,sum=0;
       for(int i=0;i<numOfPar;i++){
          // if(i==0){
             //  for(int j=0;j<numOfPar;j++){
                   
             //  }
         //  }
           for(int j=0;j<sensors.size();j++){
              v=vol(particles.get(i).x, particles.get(i).y,sensors.get(j).x,sensors.get(j).y,particles.get(i).val); 
             //d=dist(particles.get(i).x,particles.get(i).y, sensors.get(j).x,sensors.get(j).y);
              demoSnr=v;
               System.out.println(v);
              Random R1=new Random();
              demoSnr = demoSnr+R1.nextGaussian();
              sensors.get(j).snrDemo=demoSnr;
              disSnr=Math.abs(sensors.get(j).snrDemo-sensors.get(j).snr);
              sum+=disSnr;
              
           }
           particles.get(i).w = 1/(1+(sum/10));
          System.out.println(sum);
           sum=0;
       }resample(); 
    }
    public void resample(){
        double[] Weight = Normal_Weights();
        double max=0;
        for(int i=0; i<numOfPar; i++)
            max+=Weight[i];
        // System.out.println("sum of weights is "+max);
        double beta=0.0;
        Random R1 = new Random();
        Vector <particle> NewWeightedList = new Vector <particle>();
        int index = (int)(R1.nextDouble()* numOfPar);
        double mw = GetMax(Weight);
        for(int i=0; i<numOfPar; i++)
        {
            beta+=R1.nextDouble()*2*mw;
            while(beta>Weight[index])
            {
                beta-= Weight[index];
                index = (index+1)%numOfPar;
            } 
            particle tmp = new particle(particles.get(index));
            // tmp.OldWeight = ParticleList.get(index).OldWeight;
            // System.out.print(tmp.pos + " ");
            // tmp.setWeight(ParticleList.get(index).getWeight());
            NewWeightedList.add(tmp);
            c++;
            System.out.println(c+": "+ "x: "+NewWeightedList.get(i).x+"y: "+NewWeightedList.get(i).y);
            
        }
        
        for(int i=0;i<numOfPar;i++){
             //g.clearRect(particles.get(i).x,particles.get(i).y , 7, 7);
             
             g.fillRect(NewWeightedList.get(i).x+(int)(Math.random()*20),NewWeightedList.get(i).y+(int)(Math.random()*20) , 3, 3);
        }
        particles=NewWeightedList;
       
    }
    private void findJammerActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_findJammerActionPerformed
        // TODO add your handling code here:
       int calc;
       int max=Integer.MIN_VALUE;
       int tmp=0;
       int avgY=0;
       int avgX=0;
       int c=0;
       unitParticle();
       //Vector <best> drawLines= new Vector();
       Vector<sensor> temp;
       temp=sensors;  
    }
      /* 
       for(int i=0;i<numOfPoints-1;i++){
            sensor p1=temp.get(i);
            if(p1.valume>0&&p1.valume<50){
                sensor p2=temp.get(i+1);
                for(int j=i+1;j<numOfPoints;j++){
                //double d = dist(temp.get(i).x,temp.get(i).y,temp.get(j).x,temp.get(j).y);
               // System.out.println(d);
                //if(Math.abs(temp.get(i).valume-temp.get(j).valume)>0){
                    int a=temp.get(i).valume;
                    int b=temp.get(j).valume;
                    if(b>0&&b<50){
                        calc=Math.abs(a-b);
                        if (calc!=0){
                            calc=calc/2;
                            if (calc>max){ 
                                max=calc;
                                p2=temp.get(j);
                                tmp=j;
                    
                            }   
                        }
                    }
                }
                double d=Math.sqrt(dist(p1.x,p1.y,p2.x,p2.y));
                best n=new best(p1,p2,max,d);  
                bestLines.add(n);
                temp.remove(tmp);
               numOfPoints--;
                max=Integer.MIN_VALUE;
            }
        }
      int x=0;
      Vector <best> v= new Vector();
      while((x<2)&&(!bestLines.isEmpty())){
        int size=bestLines.size();
        
        best t=bestLines.poll();
        //System.out.println("valume: "+t.max+"distance: "+ t.dist);
        v.add(t);
        while((!bestLines.isEmpty())&&(t.max==bestLines.peek().max)){ 
            // System.out.println("valume: "+bestLines.peek().max+"distance: "+ bestLines.peek().dist); 
            v.add(bestLines.poll());
        }
        double minDist = Integer.MAX_VALUE;
        best b = v.elementAt(0);

        for(int i = 0;i<v.size();i++){
            if(v.elementAt(i).dist<minDist){
                minDist=v.elementAt(i).dist;
                b=v.elementAt(i);
            }
        }
        // System.out.println("bestValume: "+b.max+"bestDistance: "+ b.dist);
         //g.setColor(Color.BLACK);
        // drawLines.add(b);
         //g.drawLine(b.p1.x, b.p1.y, b.p2.x, b.p2.y);
         v.clear();
         x++;
        } 
         //int maxX1=Math.max(drawLines.get(0).p1.x,drawLines.get(0).p2.x);
         //int maxX2=Math.max(drawLines.get(1).p1.x,drawLines.get(1).p2.x);
         //int maxY1=Math.min(drawLines.get(0).p1.y,drawLines.get(0).p2.y);
         //int maxY2=Math.min(drawLines.get(1).p1.y,drawLines.get(1).p2.y);
         
         //System.out.println(maxX1+ ", "+maxX2+", "+maxY1+", "+maxY2);
         g.setColor(Color.RED);
         int size=7;
        //avgX=(int)((maxX1+maxX2)/2);
        //avgY=(int)((maxY1+maxY2)/2);
        //System.out.println(avgX+ ", "+avgY);
        //g.fillRect(avgX,avgY,size,size); 
    }//GEN-LAST:event_findJammerActionPerformed
*/
    private void actionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_actionActionPerformed
        // TODO add your handling code here: public void action(){
       // for(int j=0; j<100; j++){
            for(int i=0; i<numOfPoints; i++){
                if(sensors.get(i).ang<180){
                    sensors.get(i).x=sensors.get(i).x+1;
                    sensors.get(i).y =(int)((Math.tan(sensors.get(i).ang))+sensors.get(i).y);
                }
                double distance=dist(jammer.x,jammer.y, sensors.get(i).x,sensors.get(i).y);
                //System.out.println(distance);
                sensors.get(i).dist=distance;
                int volume=vol(jammer.x,jammer.y, sensors.get(i).x,sensors.get(i).y,jammer.val);
                //System.out.println(volume);
                sensors.get(i).valume=volume;
                sensors.get(i).snr=volume;
            
                //System.out.println(p.x + " "+p.y);
            }
           // if(j==4){
           //        g.setColor(Color.RED);
           // }
           // else if(j==8){
                //g.setColor(Color.WHITE);
          //  }
           // else if(j==12){
           //     g.setColor(Color.pink);
           // }
           // else if(j==16){
            //    g.setColor(Color.GREEN);
            //}
          //  else if(j==19){
           //     g.setColor(Color.black);
           // }   
            sense();
       // }
    
       
    }//GEN-LAST:event_actionActionPerformed
    
 /*
    /**
     * the volume will be like this: 
     * until 5 meter there is no gps reception
     * between 5 to 10 meter is 20
     * between 10 to infinity is 50 (normative reception).
 
     */
    
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(myPoints.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(myPoints.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(myPoints.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(myPoints.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new myPoints().setVisible(true);
            }
        });
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton action;
    private javax.swing.JButton findJammer;
    private javax.swing.JButton getPoints;
    private javax.swing.JFrame jFrame1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    // End of variables declaration//GEN-END:variables

   
} 
